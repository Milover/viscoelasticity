/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2106                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/

coded.normalize_fields
{
	type			coded;
	libs			("libutilityFunctionObjects.so");
	executeControl	timeStep;
	executeInterval	$long_write;
	writeControl	timeStep;
	writeInterval	$long_write;
	log				false;

	name			normalizeFields;

	rho				$:rho;
	R				$:R;
	uMax			$:u_max;

	codeInclude
	#{
		#include "turbulentTransportModel.H"
	#};

	codeOptions
	#{
		-I$(LIB_SRC)/transportModels \
		-I$(LIB_SRC)/TurbulenceModels/turbulenceModels/lnInclude \
		-I$(LIB_SRC)/TurbulenceModels/incompressible/lnInclude
	#};

	codeLibs
	#{
		-lincompressibleTransportModels \
		-lturbulenceModels \
		-lincompressibleTurbulenceModels
	#};

	codeData
	#{
		scalar rho_;	// density
		scalar R_;		// pipe radius
		vector uMax_;	// max. axial velocity for HP-flow
	#};

	codeRead
	#{
		rho_ = dict.get<scalar>("rho");
		R_ = dict.get<scalar>("R");
		uMax_ = dict.get<vector>("uMax");
	#};

	codeExecute
	#{
		const volVectorField& U = mesh().lookupObject<volVectorField>("U");
		const volScalarField& p = mesh().lookupObject<volScalarField>("p");
		const volScalarField& nu =
			lookupObject<transportModel>("transportProperties").nu();

		static autoPtr<volScalarField> pPtr;
		static autoPtr<volVectorField> UPtr;
		static const dimensionedScalar small("small", dimViscosity, SMALL);

		if (!pPtr.valid())
		{
			pPtr.set
			(
				new volScalarField
				(
					IOobject
					(
						"pDimless",
						mesh().time().timeName(),
						mesh(),
						IOobject::NO_READ,
						IOobject::AUTO_WRITE
					),
					p * R_ / (rho_ * nu * mag(uMax_) + small)
				)
			);
		}
		if (!UPtr.valid())
		{
			UPtr.set
			(
				new volVectorField
				(
					IOobject
					(
						"UDimless",
						mesh().time().timeName(),
						mesh(),
						IOobject::NO_READ,
						IOobject::AUTO_WRITE
					),
					U / (mag(uMax_) + SMALL)
				)
			);
		}

		volScalarField& pDimless = pPtr();
		volVectorField& UDimless = UPtr();

		pDimless.checkIn();
		UDimless.checkIn();

		pDimless = p * R_ / (rho_ * nu * mag(uMax_) + small);
		UDimless = U / (mag(uMax_) + SMALL);
	#};

	codeWrite
	#{
		const volScalarField& pDimless =
			mesh().lookupObject<volScalarField>("pDimless");
		const volVectorField& UDimless =
			mesh().lookupObject<volVectorField>("UDimless");

		pDimless.write();
		UDimless.write();
	#};
}

// ************************************************************************* //
